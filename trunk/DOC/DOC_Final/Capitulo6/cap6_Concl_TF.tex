\chapter{Conclusiones y trabajo a futuro} % 5 páginas mas o menos...

Tomando en cuenta los objetivos definidos al inicio de este trabajo, es posible afirmar que las metas propuestas se lograron exitosamente.

El trabajo se inició con un estudio general de los distintos métodos de generación de imágenes por computadora, con mayor profundidad en el algoritmo de \emph{ray tracing} propuesto por Turner Whitted. Posteriormente se continuó con un estudio sobre la utilización de GPUs como plataforma de ejecución de aplicaciones paralelas. Se investigaron aspectos de la arquitectura de las GPUs, y especialmente herramientas para su programación, y en particular el lenguaje de programación CUDA. Luego se continuó con un relevamiento de los diversos métodos de aceleración para el algoritmo de \emph{ray tracing}, haciendo énfasis en los métodos de aceleración espacial y sus implementaciones sobre GPUs. Por último, se realizó un relevamiento del estado del arte de algoritmos de \emph{ray tracing} interactivos, haciendo hincapié en los algoritmos interactivos implementados sobre arquitecturas multiprocesador de memoria compartida. En estas etapas se adquirieron valiosos conocimientos que luego permitieron realizar el diseño e implementación de las soluciones propuestas.

Siguiendo un proceso de desarrollo iterativo e incremental, se realizó la implementación del algoritmo de \emph{ray tracing} sobre GPU paralelizando a nivel de rayos primarios y utilizando una sub-división espacial uniforme para disminuir la cantidad de evaluaciones de intersección rayo-triángulo. De la primera iteración del proceso surgió como resultado la versión llamada RT-GPU, la cual permite generar imágenes utilizando la GPU para acelerar el cómputo. Sin embargo, no explota al máximo la jerarquía de memoria de la GPU y no utiliza un algoritmo de intersección rayo-triángulo optimizado. En la siguiente i\-te\-ra\-ción se implementó una estrategia que permite el uso eficiente de la jerarquía de memoria de la GPU por parte del algoritmo de \emph{ray tracing}, dando lugar a la versión llamada RT-GPU-JM. Posteriormente, en la última iteración se optimizó el algoritmo de intersección rayo-triángulo y se obtuvo la versión final del algoritmo de \emph{ray tracing} implementado sobre GPU, RT-GPU-JM-IR. Asimismo para cada versión del algoritmo implementado sobre GPU se implementó una versión equivalente para CPU, de forma de evaluar la aceleración lograda al paralelizar el algoritmo sobre GPU.

Otro resultado importante del proyecto es un conjunto de casos de prueba para evaluar algoritmos de iluminación. En una primera etapa se relevó la existencia de \emph{benchmarks} para evaluar este tipo de algoritmo, este relevamiento no permitió establecer un conjunto de casos de prueba que se adaptaran a la realidad de este proyecto. Por esta razón, durante el proceso de implementación se diseñaron y construyeron diversos casos de prueba con el propósito de evaluar el desempeño de cada versión del algoritmo. Los casos de prueba fueron diseñados para cubrir distintos aspectos que se consideraron importantes, por ejemplo puntos débiles de la estructura de aceleración espacial empleada, desempeño del algoritmo frente a variaciones de la cantidad de triángulos de la escena, comparación de desempeño con el estado del arte en la materia y la escalabilidad en las plataformas de prueba.

Los resultados de las pruebas de comparación entre las diferentes versiones del algoritmo para GPU permitieron concluir que el correcto uso de la jerarquía de memoria de la GPU es muy importante, ya que la aceleración lograda al pasar de la versión RT-GPU a la versión RT-GPU-JM fue de más de 3x. Se observa también que la importancia de minimizar los accesos a la memoria global de la GPU, utilizando la memoria compartida disponible entre bloques de threads o la memoria de textura siempre que sea posible, ya que la diferencia de velocidades entre ambas memorias y la memoria global es muy importante. Los resultados obtenidos al realizar pruebas de desempeño comparando las últimas dos versiones implementadas para GPU permiten concluir que es determinante que el \emph{ray tracing} incluya un algoritmo eficiente de chequeo de intersección rayo-triángulo, ya que reduciendo un cuarto la cantidad de operaciones aritméticas del chequeo se logró un 30 \% más de velocidad en la generación de la imagen.

Las pruebas de comparación de desempeño entre la versión final del algoritmo para GPU y su correspondiente para CPU permitieron concluir que el objetivo de acelerar el algoritmo de \emph{ray tracing} fue alcanzado con éxito. Todas las pruebas realizadas en este sentido arrojaron que el algoritmo para GPU es más rápido que su correspondiente para CPU, llegando en el mejor caso hasta una aceleración que supera los 13x.

Por otro lado, la comparación entre GPU y CPU permitió concluir que el tamaño de la grilla de aceleración espacial es independiente del \emph{hardware} donde ejecute el algoritmo y que solo depende de la cantidad de triángulos que componen la escena, ya que para todas las escenas de prueba el tamaño de grilla donde se logran más FPS (grilla óptima) es el mismo en GPU que en CPU.

Se utilizaron cuatro GPUs sobre los sistemas operativos \emph{Windows} y \emph{Linux} para ejecutar los casos de prueba diseñados, los datos obtenidos permitieron arribar a conclusiones importantes. Los datos de desempeño obtenidos al ejecutar los mismos casos de prueba sobre distintas plataformas usando la versión final del algoritmo para GPU permiten concluir que, para escenas complejas (100.000 triángulos en el contexto de este proyecto), cuanto más procesadores posea la GPU más rápido será la generación de imágenes mediante el algoritmo de \emph{ray tracing} para CUDA. Asimismo se concluye que para escenas simples el \emph{overhead} introducido por demasiado paralelismo puede afectar el tiempo de generación de imagen. Sin duda la propiedad del algoritmo más sobresaliente es la escalabilidad automática en el número de procesadores de la GPU. Este es un beneficio del modelo de programación de CUDA y permite lograr mejores resultados día a día dado el vertiginoso crecimiento del poder de computo de las GPUs actuales.

Los resultados de las pruebas de comparación entre la versión final del algoritmo implementado en este proyecto y algoritmos desarrollados en otros proyectos similares demostraron que la propuesta del proyecto es competitivo con el estado del arte en la materia, tanto en tiempo de generación como en calidad de imagen.

Algunos aspectos del trabajo fueron validados mediante la presentación de un artículo de divulgación científica, \emph{Improving the Performance of the Ray Tracing Algorithm with a GPU}, en las JCC 2010 (Jornadas Chilenas de Computación de 2010). El artículo fue aceptado, y será incluido en las actas de la conferencia. La versión preliminar del artículo se encuentra en el Apéndice \ref{sec:ApendiceArticuloIEEE}.

Como conclusión final se puede destacar que el método de aceleración mediante GPU alcanzó tiempos de generación de imágenes que permiten abordar estrategias interactivas para escenas simples. Además la aceleración lograda no implica pérdida de calidad de imagen, ya que en ninguna de las ejecuciones de los casos de prueba se verificaron diferencias entre imágenes generadas en GPU y en CPU.

A partir del trabajo realizado y las conclusiones extraídas, es posible identificar diversas líneas de trabajo futuro que se presentan a continuación.

Una primera línea de trabajo a futuro es mejorar la estructura de a\-ce\-le\-ra\-ción espacial del algoritmo de \emph{ray tracing} implementado. La primer opción es optimizar la grilla uniforme que se utiliza actualmente, para optimizarla se puede agregar una etapa más a su algoritmo de construcción para convertir en una sola caja varias cajas vacías (o que contengan menos de $k$ triángulos en su interior). Otra opción es cambiar la estructura uniforme por una estructura que se adapte más a la escena, como la kd-tree. Luego de analizado el estado del arte en esta materia en el transcurso de este proyecto de grado, se piensa que con la estructura kd-tree se obtendrían mejores resultados. De esta manera se podría elevar el límite de cantidad de triángulos que tiene el algoritmo actual para renderizar escenas en tiempos interactivos.

En cuanto a mejorar la calidad de las imágenes una línea de trabajo es introducir algún método de \emph{antialiasing}, como por ejemplo \emph{supersampling}, \emph{adaptive sampling} o \emph{stochastic sampling}. Otra opción de mejora en este sentido es eliminar la restricción que tiene el algoritmo actual en cuanto a que las escenas no pueden tener objetos reflexivos y transparentes a la vez. Para remover esta restricción es necesario implementar un \emph{stack} a nivel de la GPU para manejar un árbol de rayos en lugar de una lista como se maneja actualmente.

En cuanto a diseño global del algoritmo una línea de trabajo es re-diseñar los \emph{kernels} utilizados por el algoritmo propuesto. Actualmente existe un \emph{kernel} principal que se encarga de lanzar los rayos primarios, luego lanzar los de sombra, posteriormente lanzar los rayos de reflexión y refracción y por último calcular el color del píxel. Este diseño tiene problemas porque para escenas complejas el \emph{kernel} principal tiene un tiempo de ejecución demasiado alto y es abortado por el sistema operativo. La estrategia que podría solucionar este problema es dividir el \emph{kernel} principal en varios \emph{kernels} más pequeños, donde cada uno tenga la responsabilidad de hacer parte del trabajo que hace el principal en la actual implementación.

La siguiente línea de trabajo es a más largo plazo y consiste en estudiar en profundidad otros algoritmos de generación de imágenes, como \emph{radiosidad} o \emph{photon mapping}, y sus implementaciones sobre GPUs, de modo de aprovechar la experiencia en programación sobre GPUs adquirida en este proyecto de grado aplicada a otras herramientas del área.

El impulso de OpenCL como estándar de programación de GPUs, para todas las tecnologías y no solo para NVIDIA, sugiere otra línea de trabajo futuro a más largo plazo, que consiste en evaluar la utilización de otros lenguajes de programación, en particular OpenCL. También sería interesante lograr un \emph{ray tracing} que utilice varias GPUs y que sea capaz de dividir la generación de la imagen entre ellas.

